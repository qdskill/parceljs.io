<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>🔌 插件</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link type="text/css" rel="stylesheet" href="assets/style.css" />
  <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
  <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110647385-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110647385-1');
  </script>
</head>
<body>
  <header>
    <a class="logo" href="/">
      <img class="parcel" src="assets/parcel.png" srcset="assets/parcel@2x.png 2x, assets/parcel@3x.png 3x" height="30">
      <img class="type" src="assets/logo.svg" alt="Parcel">
    </a>
    <div class="links">
      <a href="https://github.com/parcel-bundler/parcel" target="_blank">GitHub</a>
    </div>
  </header>
  <div class="content">
    <nav>
      <ul>
        <li><a href="getting_started.html">🚀 快速开始</a></li>
        <li><a href="assets.html">📦 资源</a></li>
        <li><a href="transforms.html">🐠 转换</a></li>
        <li><a href="code_splitting.html">✂️ 代码拆分</a></li>
        <li><a href="hmr.html">🔥 热模块替换</a></li>
        <li><a href="production.html">✨ 生产环境</a></li>
      </ul>
      <h3>进阶</h3>
      <ul>
        <li><a href="how_it_works.html">🛠 它如何运作</a></li>
        <li><a href="asset_types.html">📝 资源类型</a></li>
        <li><a href="packagers.html">📦 Packagers</a></li>
        <li><a href="plugins.html">🔌 插件</a></li>
      </ul>
    </nav>
    <main><h1 id="🔌-插件"><a class="header-link" href="#🔌-插件"></a>🔌 插件</h1>
<p>Parcel 采用与许多其它工具稍微不同的策略，许多常见的格式都被开箱即用地包含进来，而不需要安装或者配置额外的插件。然而，有些情况你可能会想在非标准的情况下扩展 Parcel 的能力，而那些时候，插件是被支持的。安装的插件会基于 <code>package.json</code> 的依赖会被自动检测并加载。</p>
<p>当你添加一种全新的文件格式到 Parcel，你应该先考虑它会有多通用，还有它的实现会有多标准化。如果它足够通用及标准，该格式很可能应该被添加到 Parcel 的核心，而不是作为一种用户需要安装的插件。如果你有其它的疑惑，可以到<a href="https://github.com/parcel-bundler/parcel/issues">GitHub</a>一起讨论。</p>
<h2 id="插件-api"><a class="header-link" href="#插件-api"></a>插件 API</h2>
<p>Parcel 插件很简单。它们只是简单地将几个模块输出成一个函数，它会被 Parcel 在初始化的时候自动调用。函数接收 <code>Bundler</code> 对象作为输入，也可以做一些配置，比如注册资源类型和注册 packager。</p>
<pre class="hljs"><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bundler</span>) </span>{
  bundler.addAssetType(<span class="hljs-string">'ext'</span>, <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">'./MyAsset'</span>));
  bundler.addPackager(<span class="hljs-string">'foo'</span>, <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">'./MyPackager'</span>));
};</code></pre><p>请发布这个包到 npm，并使用 <code>parcel-plugin-</code> 前缀，那它就会将后文提到的那样被自动检测和加载。</p>
<h2 id="使用插件"><a class="header-link" href="#使用插件"></a>使用插件</h2>
<p>在 Parcel 中使用插件是前所未有地简单。你所做的，只是将它们安装好并保存到 <code>package.json</code> 中。插件需要以 <code>parcel-plugin-</code> 作为前缀被命名。例如 <code>parcel-plugin-foo</code>。任何在 <code>package.json</code> 中被列出的带有此前缀的依赖，都会在初始化的时候被自动加载。</p>
    </main>
  </div>
  <script>
    (function () {
      var activeLink = Array.from(document.querySelectorAll('nav a')).find(function (a) {
        return a.href === window.location.href;
      });

      activeLink.classList.add('selected');
    })();
  </script>
</body>
</html>
